import 'dart:convert';
import 'dart:async';
import 'dart:io';
import 'package:flutter/foundation.dart' show kIsWeb;
import 'package:flutter/services.dart' show rootBundle;
import 'package:http/http.dart' as http;
import '../../features/profile/user_profile.dart';
import 'local_generator.dart';

class AiConfig {
  final String serverUrl;
  final String streamUrl; // optional
  final String model;
  final String appToken; // optional
  AiConfig({required this.serverUrl, required this.model, this.streamUrl = '', this.appToken = ''});
  static Future<AiConfig> load() async {
    try {
      final txt = await rootBundle.loadString('assets/config/ai.json');
      final j = json.decode(txt) as Map<String, dynamic>;
      return AiConfig(
        serverUrl: (j['serverUrl'] ?? '') as String,
        model: (j['model'] ?? 'gpt-4o-mini') as String,
        streamUrl: (j['streamUrl'] ?? '') as String,
        appToken: (j['appToken'] ?? '') as String,
      );
    } catch (_) {
      return AiConfig(serverUrl: '', model: 'gpt-4o-mini');
    }
  }
}

class AiService {
  // ignore: unused_field
  static String? _apiKey; // --dart-define=OPENAI_API_KEY

  static void configure({String? openAIApiKey}) {
    _apiKey = openAIApiKey ?? const String.fromEnvironment('OPENAI_API_KEY');
  }

  static Future<String> generate({
    required String type,
    required UserProfile profile,
    Map<String, dynamic>? extras,
    String locale = 'tr',
  }) async {
    // forceLocal bayragi artik dikkate alinmiyor; her zaman once uzak sunucu denenir
    // Optional remote server
    final cfg = await AiConfig.load();
    var server = cfg.serverUrl;
    // Android emulator uses 10.0.2.2 for host loopback
    if (server.contains('127.0.0.1') && Platform.isAndroid) {
      server = server.replaceAll('127.0.0.1', '10.0.2.2');
    }
    if (server.isNotEmpty) {
      // Tek tekrar denemesi + daha uzun zaman aþýmý (Render gibi cold start senaryolarý için)
      final payload = {
        'type': type,
        'profile': profile.toJson(),
        'inputs': await _prepareInputs(extras),
        'locale': locale,
        'context': _contextInfo(locale: locale),
        'model': cfg.model,
      };
      for (var attempt = 0; attempt < 2; attempt++) {
        try {
          final r = await http
              .post(
                Uri.parse(server),
                headers: {
                  HttpHeaders.contentTypeHeader: 'application/json',
                  if (cfg.appToken.isNotEmpty) HttpHeaders.authorizationHeader: 'Bearer ${cfg.appToken}',
                },
                body: json.encode(payload),
              )
              .timeout(const Duration(seconds: 20));
          if (r.statusCode >= 200 && r.statusCode < 300) {
            final j = json.decode(r.body) as Map<String, dynamic>;
            final text = (j['text'] as String?)?.trim();
            if (text != null && text.isNotEmpty) {
              // Only coffee closes are added later in ResultPage; return raw text here
              return text;
            }
          } else {
            // Sunucu anlamlý hata dondurduysa (401/503 vb.), tekrar denemeyi kesmek mantýklý
            if (r.statusCode == 401 || r.statusCode == 403 || r.statusCode == 503) break;
          }
        } catch (_) {
          // ilk deneme zaman aþýmý/baðlantý sorununda bir kez daha dene
        }
        // küçük bekleme sonrasý bir deneme daha
        await Future.delayed(const Duration(seconds: 2));
      }
    }
    // Local/template fallback when remote is unavailable
    try {
      final local = LocalAIGenerator.generate(
        type: type,
        profile: profile,
        extras: extras,
        locale: locale,
      ).trim();
      if (local.isNotEmpty) return local;
    } catch (_) {}
    return 'Uretim su anda yapilamiyor. Lutfen biraz sonra tekrar dene.';
  }

  // Live chat streaming (local streaming if no API key). Options allow tone/length.
  static Stream<String> streamLiveChat({
    required UserProfile profile,
    required List<Map<String, dynamic>> history,
    required String text,
    String locale = 'tr',
    Map<String, dynamic>? options,
  }) async* {
    // Prefer remote streaming if configured
    final cfg = await AiConfig.load();
    var streamUrl = cfg.streamUrl;
    if (streamUrl.contains('127.0.0.1') && Platform.isAndroid) {
      streamUrl = streamUrl.replaceAll('127.0.0.1', '10.0.2.2');
    }
    if (streamUrl.isNotEmpty) {
      try {
        final req = {
          'type': 'live_chat',
          'profile': profile.toJson(),
          'inputs': {
            'text': text,
            'history': history,
            if (options != null) ...options,
          },
          'locale': locale,
          'context': _contextInfo(locale: locale),
          'model': cfg.model,
        };
        final client = http.Client();
        try {
          final httpReq = http.Request('POST', Uri.parse(streamUrl));
          httpReq.headers[HttpHeaders.contentTypeHeader] = 'application/json';
          if (cfg.appToken.isNotEmpty) {
            httpReq.headers[HttpHeaders.authorizationHeader] = 'Bearer ${cfg.appToken}';
          }
          httpReq.body = json.encode(req);
          final streamed = await client.send(httpReq).timeout(const Duration(seconds: 20));
          if (streamed.statusCode >= 200 && streamed.statusCode < 300) {
            final buf = StringBuffer();
            var carry = '';
            await for (final chunk in streamed.stream.transform(const Utf8Decoder())) {
              final combined = carry + chunk;
              final lines = combined.split(RegExp('\\r?\\n'));
              carry = lines.isNotEmpty ? lines.removeLast() : '';
              for (final raw in lines) {
                final line = raw.trim();
                if (line.isEmpty) continue;
                String piece = line;
                if (piece.startsWith('data:')) {
                  piece = piece.substring(5);
                  try {
                    final j = json.decode(piece);
                    final val = (j is Map<String, dynamic>) ? (j['delta'] ?? j['text'] ?? j['content'] ?? j['data']) : null;
                    if (val is String) piece = val;
                  } catch (_) {}
                }
                if (piece.isEmpty) continue;
                buf.write(piece);
                yield buf.toString();
              }
            }
            if (carry.isNotEmpty) {
              buf.write(carry);
              yield buf.toString();
            }
            client.close();
            return;
          }
        } on TimeoutException {
          try { client.close(); } catch (_) {}
        } finally {
          try { client.close(); } catch (_) {}
        }
      } catch (_) {}
    }

    // Fallback: local generator if remote unavailable
    final base = LocalAIGenerator.generate(
      type: 'live_chat',
      profile: profile,
      extras: {'text': text, 'history': history, if (options != null) ...options},
      locale: locale,
    );
    final words = base.split(' ');
    final buffer = StringBuffer();
    for (var i = 0; i < words.length; i++) {
      buffer.write(words[i]);
      if (i < words.length - 1) buffer.write(' ');
      if (i % 6 == 0 || i == words.length - 1) {
        yield buffer.toString();
        await Future.delayed(const Duration(milliseconds: 18));
      }
    }
    yield buffer.toString();
  }

  // Simple text streaming for readings. Tries remote stream, falls back to local chunking.
  static Stream<String> streamGenerate({
    required String type,
    required UserProfile profile,
    Map<String, dynamic>? extras,
    String locale = 'tr',
  }) async* {
    // Try remote streaming if configured
    final cfg = await AiConfig.load();
    var streamUrl = cfg.streamUrl;
    if (streamUrl.contains('127.0.0.1') && Platform.isAndroid) {
      streamUrl = streamUrl.replaceAll('127.0.0.1', '10.0.2.2');
    }
    if (streamUrl.isNotEmpty) {
      try {
        final req = {
          'type': type,
          'profile': profile.toJson(),
